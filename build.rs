use std::process::Command;

fn main() {
	std::fs::create_dir("compiled_srcs/");
	Command::new("nasm")
		.args([
			"-felf32",
			"-MP",
			"-MD",
			"compiled_srcs/boot.d",
			"-I",
			"includes",
			"-o",
			"compiled_srcs/boot.o",
			"srcs/boot/boot.s"
		])
		.status()
		.unwrap();
	Command::new("nasm")
		.args([
			"-felf32",
			"-MP",
			"-MD",
			"compiled_srcs/gdt.d",
			"-I",
			"includes",
			"-o",
			"compiled_srcs/gdt.o",
			"srcs/gdt/gdt.s"
		])
		.status()
		.unwrap();
	Command::new("nasm")
		.args([
			"-felf32",
			"-MP",
			"-MD",
			"compiled_srcs/idt.d",
			"-I",
			"includes",
			"-o",
			"compiled_srcs/idt.o",
			"srcs/interrupts/idt.s"
		])
		.status()
		.unwrap();
	Command::new("nasm")
		.args([
			"-felf32",
			"-MP",
			"-MD",
			"compiled_srcs/int.d",
			"-I",
			"includes",
			"-o",
			"compiled_srcs/int.o",
			"srcs/interrupts/int.s"
		])
		.status()
		.unwrap();
	Command::new("nasm")
		.args([
			"-felf32",
			"-MP",
			"-MD",
			"compiled_srcs/userjump.d",
			"-I",
			"includes",
			"-o",
			"compiled_srcs/userjump.o",
			"srcs/user/userjump.s"
		])
		.status()
		.unwrap();
	Command::new("nasm")
		.args([
			"-felf32",
			"-MP",
			"-MD",
			"compiled_srcs/task.d",
			"-I",
			"includes",
			"-o",
			"compiled_srcs/task.o",
			"srcs/proc/task.s"
		])
		.status()
		.unwrap();
	Command::new("i386-elf-ar")
		.args([
			"rc",
			"libboot.a",
			"compiled_srcs/boot.o",
			"compiled_srcs/gdt.o",
			"compiled_srcs/idt.o",
			"compiled_srcs/int.o",
			"compiled_srcs/userjump.o",
			"compiled_srcs/task.o"
		])
		.status()
		.unwrap();

	// Linking the C/asm library
	println!("cargo:rustc-link-search=native=./");

	println!("cargo:rustc-link-lib=static=boot");
	println!("cargo:rerun-if-changed=libboot.a");

	// Adding the linker script
	println!("cargo:rustc-link-arg=-Tarch/x86/linker.ld");
	println!("cargo:rerun-if-changed=arch/x86/linker.ld");
}
